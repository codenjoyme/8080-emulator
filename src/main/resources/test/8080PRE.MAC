; prelim.z80 - Preliminary Z80 tests
; Copyright (C) 1994  Frank D. Cringle
;
; This program is free software; you can redistribute it and/or
; modify it under the terms of the GNU General Public License
; as published by the Free Software Foundation; either version 2
; of the License, or (at your option) any later version.
;
; This program is distributed in the hope that it will be useful,
; but WITHOUT ANY WARRANTY; without even the implied warranty of
; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
; GNU General Public License for more details.
;
; You should have received a copy of the GNU General Public License
; along with this program; if not, write to the Free Software
; Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.


; These tests have two goals.  To start with, we assume the worst and
; successively test the instructions needed to continue testing.
; Then we try to test all instructions which cannot be handled by
; zexlax - the crc-based instruction exerciser.

; Initially errors are 'reported' by jumping to 0.  This should reboot
; cp/m, so if the program terminates without any output one of the
; early tests failed.  Later errors are reported by outputting an
; address via the bdos conout routine.  The address can be located in
; a listing of this program.

; If the program runs to completion it displays a suitable message.

;******************************************************************************
;
; Modified by Ian Bartholomew to run a preliminary test on an 8080 CPU
;
; Assemble using M80
;
;******************************************************************************

        .PROJECT 8080PRE.COM
        CPU 8080
        ASEG
        ORG     100h

start:  MVI     a,1        ; test simple compares and z/nz jumps
        CPI     2
        JZ      0
        CPI     1
        JNZ     0
        JMP     lab0
        HLT                ; emergency exit
        DB      0FFh
            
lab0:   CALL    lab2       ; does a simple call work?
lab1:   JMP     0          ; fail
            
lab2:   POP     h          ; check return address
        MOV     A,H
        CPI     HIGH lab1
        JZ      lab3
        JMP     0
lab3:   MOV     A,L
        CPI     LOW lab1
        JZ      lab4
        JMP     0

; test presence and uniqueness of all machine registers
; (except ir)
lab4:   LXI     SP,regs1
        POP     PSW
        POP     B
        POP     D
        POP     H
        LXI     SP,regs2+8
        PUSH    H
        PUSH    D
        PUSH    B
        PUSH    PSW

v       DEFL    0
        REPT    8
        LDA     regs2+v/2
v       DEFL    v+2
        CPI     v
        JNZ     0
        ENDM

; test access to memory via (hl)        
        LXI     H,hlval
        MOV     A,M
        CPI     0A5h
        JNZ     0
        LXI     H,hlval+1
        MOV     A,M
        CPI     03Ch
        JNZ     0

; test unconditional return        
        LXI     SP,stack
        LXI     H,reta
        PUSH    H
        RET
        JMP     0

; test instructions needed for hex output
reta:   MVI     A,0FFh
        ANI     0Fh
        CPI     0Fh
        JNZ     0
        MVI     A,05Ah
        ANI     0Fh
        CPI     0Ah
        JNZ     0
        RRC
        CPI     05h
        JNZ     0
        RRC
        CPI     82h
        JNZ     0
        RRC
        CPI     41h
        JNZ     0
        RRC
        CPI     0A0h
        JNZ     0
        LXI     H,01234h
        PUSH    H
        POP     B
        MOV     A,B
        CPI     12h
        JNZ     0
        MOV     A,C
        CPI     34h
        JNZ     0
        
; from now on we can report errors by displaying an address

; test conditional call, ret, jp, jr
tcond   macro   flag,pcond,ncond,rel
        LXI     H,&flag
        PUSH    H
        POP     PSW
        c&pcond lab1&pcond
        JMP     error
lab1&pcond:
        POP     H
        LXI     H,0D7h xor &flag
        PUSH    H
        POP     PSW
        c&ncond lab2&pcond
        JMP     error
lab2&pcond:
        POP     H
        LXI     H,lab3&pcond
        PUSH    H
        LXI     H,&flag
        PUSH    H
        POP     PSW
        r&pcond    
        CALL    error
lab3&pcond:
        LXI     H,lab4&pcond
        PUSH    H
        LXI     H,0D7h XOR &flag
        PUSH    H
        POP     PSW
        r&ncond    
        CALL    error
lab4&pcond:
        LXI     H,&flag
        PUSH    H
        POP     PSW
        j&pcond lab5&pcond
        CALL    error
lab5&pcond:
        LXI     H,0D7h
        XOR     &flag
        PUSH    H
        POP     PSW
        j&ncond lab6&pcond
        CALL    error
lab6&pcond:        
        endm
    
        tcond   1,c,nc,1
        tcond   4,pe,po,0
        tcond   040h,z,nz,1
        tcond   080h,m,p,0

; test indirect jumps    
        LXI     H,lab7
        PCHL
        CALL    error

; djnz (and (partially) inc a, inc hl)
lab7:   MVI    A,0A5h
        MVI    B,4
lab8:   RRC
        DCR    B
        JNZ    lab8
        CPI    05Ah
        CNZ    error
        MVI    B,16
lab9:   INR    A
        DCR    B
        JNZ    lab9
        CPI    06Ah
        CNZ    error
        MVI    B,0
        LXI    H,0
lab10:  INX    H
        DCR    B
        JNZ    lab10
        MOV    A,H
        CPI    1
        CNZ    error
        MOV    A,l
        CPI    0
        CNZ    error
        
allok:  LXI    D,okmsg
        MVI    C,9
        CALL   5
        JMP    0

okmsg:  DB    '8080 Preliminary tests complete$'
        
; display address at top of stack and exit
error:  POP    B
        MVI    H,HIGH hextab
        MOV    A,B
        RRC
        RRC
        RRC
        RRC
        ANI    15
        MOV    L,A
        MOV    A,M
        CALL   conout
        MOV    A,B
        ANI    15
        MOV    L,A
        MOV    A,M
        CALL   conout
        MOV    A,C
        RRC
        RRC
        RRC
        RRC
        ANI    15
        MOV    L,A
        MOV    A,M
        CALL   conout
        MOV    A,C
        ANI    15
        MOV    L,A
        MOV    A,M
        CALL   conout
        MVI    A,13
        CALL   conout
        MVI    A,10
        CALL   conout
        JMP    0

conout: PUSH   PSW
        PUSH   B
        PUSH   D
        PUSH   H
        MVI    C,2
        MOV    E,A
        CALL   5
        POP    H
        POP    D
        POP    B
        POP    PSW
        RET
        
v       DEFL   0
regs1:  REPT   8
v       DEFL   v+2
        DB     v
        ENDM

regs2:  DS     8,0

hlval:  DB     0A5h,03Ch

; skip to next page boundary    
        ORG    (($+255)/256)*256
hextab: DB     '0123456789abcdef'
        DS     240

stack   EQU    $
    
        END    start