; prelim.z80 - Preliminary Z80 tests
; Copyright (C) 1994  Frank D. Cringle
;
; This program is free software; you can redistribute it and/or
; modify it under the terms of the GNU General Public License
; as published by the Free Software Foundation; either version 2
; of the License, or (at your option) any later version.
;
; This program is distributed in the hope that it will be useful,
; but WITHOUT ANY WARRANTY; without even the implied warranty of
; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
; GNU General Public License for more details.
;
; You should have received a copy of the GNU General Public License
; along with this program; if not, write to the Free Software
; Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.


; These tests have two goals.  To start with, we assume the worst and
; successively test the instructions needed to continue testing.
; Then we try to test all instructions which cannot be handled by
; zexlax - the crc-based instruction exerciser.

; Initially errors are 'reported' by jumping to 0.  This should reboot
; cp/m, so if the program terminates without any output one of the
; early tests failed.  Later errors are reported by outputting an
; address via the bdos conout routine.  The address can be located in
; a listing of this program.

; If the program runs to completion it displays a suitable message.

;******************************************************************************
;
; Modified by Ian Bartholomew to run a preliminary test on an 8080 CPU
;
; Modified by Oleksandr Baglai to be able to assemble with
;     https://svofski.github.io/pretty-8080-assembler/
;
;******************************************************************************

        .PROJECT 8080PRE.COM
        CPU 8080
        ASEG
        ORG     100h

start:  MVI     a,1        ; test simple compares and z/nz jumps
        CPI     2
        JZ      0
        CPI     1
        JNZ     0
        JMP     lab0
        HLT                ; emergency exit
        DB      0FFh

lab0:   CALL    lab2       ; does a simple call work?
lab1:   JMP     0          ; fail

lab2:   POP     h          ; check return address
        MOV     A,H
        CPI     (lab1 / 0FFh)
        JZ      lab3
        JMP     0
lab3:   MOV     A,L
        CPI     (lab1 & 0FFh)
        JZ      lab4
        JMP     0

; test presence and uniqueness of all machine registers
; (except ir)
lab4:   LXI     SP,regs1
        POP     PSW
        POP     B
        POP     D
        POP     H
        LXI     SP,regs2+8
        PUSH    H
        PUSH    D
        PUSH    B
        PUSH    PSW

        LDA     regs2 + 0/2
        CPI     2
        JNZ     0
        LDA     regs2 + 2/2
        CPI     4
        JNZ     0
        LDA     regs2 + 4/2
        CPI     6
        JNZ     0
        LDA     regs2 + 6/2
        CPI     8
        JNZ     0
        LDA     regs2 + 8/2
        CPI     10
        JNZ     0
        LDA     regs2 + 10/2
        CPI     12
        JNZ     0
        LDA     regs2 + 12/2
        CPI     14
        JNZ     0
        LDA     regs2 + 14/2
        CPI     16
        JNZ     0

; test access to memory via (hl)
        LXI     H,hlval
        MOV     A,M
        CPI     0A5h
        JNZ     0
        LXI     H,hlval+1
        MOV     A,M
        CPI     03Ch
        JNZ     0

; test unconditional return
        LXI     SP,stack
        LXI     H,reta
        PUSH    H
        RET
        JMP     0

; test instructions needed for hex output
reta:   MVI     A,0FFh
        ANI     0Fh
        CPI     0Fh
        JNZ     0
        MVI     A,05Ah
        ANI     0Fh
        CPI     0Ah
        JNZ     0
        RRC
        CPI     05h
        JNZ     0
        RRC
        CPI     82h
        JNZ     0
        RRC
        CPI     41h
        JNZ     0
        RRC
        CPI     0A0h
        JNZ     0
        LXI     H,01234h
        PUSH    H
        POP     B
        MOV     A,B
        CPI     12h
        JNZ     0
        MOV     A,C
        CPI     34h
        JNZ     0

; from now on we can report errors by displaying an address

; test conditional call, ret, jp, jr
; commands CC, CNC, JC, JNC, RC, RNC
lab0_c:
        LXI     H,001h            ; FLAG
        PUSH    H
        POP     PSW
        CC      lab1_c
        JMP     error
lab1_c:
        POP     H
        LXI     H,0D7h ^ 001h     ; FLAG
        PUSH    H
        POP     PSW
        CNC     lab2_c
        JMP     error
lab2_c:
        POP     H
        LXI     H,lab3_c
        PUSH    H
        LXI     H,001h            ; FLAG
        PUSH    H
        POP     PSW
        RC
        CALL    error
lab3_c:
        LXI     H,lab4_c
        PUSH    H
        LXI     H,0D7h ^ 001h     ; FLAG
        PUSH    H
        POP     PSW
        rNC
        CALL    error
lab4_c:
        LXI     H,001h            ; FLAG
        PUSH    H
        POP     PSW
        JC      lab5_c
        CALL    error
lab5_c:
        LXI     H,0D7h ^ 001h     ; FLAG
        PUSH    H
        POP     PSW
        JNC     lab6_c
        CALL    error
lab6_c:

; commands CPE, CPO, JPE, JPO, RPE, RPO
lab0_p:
        LXI     H,004h            ; FLAG
        PUSH    H
        POP     PSW
        CPE     lab1_p
        JMP     error
lab1_p:
        POP     H
        LXI     H,0D7h ^ 004h     ; FLAG
        PUSH    H
        POP     PSW
        CPO     lab2_p
        JMP     error
lab2_p:
        POP     H
        LXI     H,lab3_p
        PUSH    H
        LXI     H,004h            ; FLAG
        PUSH    H
        POP     PSW
        RPE
        CALL    error
lab3_p:
        LXI     H,lab4_p
        PUSH    H
        LXI     H,0D7h ^ 004h     ; FLAG
        PUSH    H
        POP     PSW
        RPO
        CALL    error
lab4_p:
        LXI     H,004h            ; FLAG
        PUSH    H
        POP     PSW
        JPE     lab5_p
        CALL    error
lab5_p:
        LXI     H,0D7h ^ 004h     ; FLAG
        PUSH    H
        POP     PSW
        JPO     lab6_p
        CALL    error
lab6_p:

; commands CZ, CNZ, JZ, JNZ, RZ, RNZ
lab0_z:
        LXI     H,040h            ; FLAG
        PUSH    H
        POP     PSW
        CZ      lab1_z
        JMP     error
lab1_z:
        POP     H
        LXI     H,0D7h ^ 040h     ; FLAG
        PUSH    H
        POP     PSW
        CNZ     lab2_z
        JMP     error
lab2_z:
        POP     H
        LXI     H,lab3_z
        PUSH    H
        LXI     H,040h            ; FLAG
        PUSH    H
        POP     PSW
        RZ
        CALL    error
lab3_z:
        LXI     H,lab4_z
        PUSH    H
        LXI     H,0D7h ^ 040h     ; FLAG
        PUSH    H
        POP     PSW
        RNZ
        CALL    error
lab4_z:
        LXI     H,040h            ; FLAG
        PUSH    H
        POP     PSW
        JZ      lab5_z
        CALL    error
lab5_z:
        LXI     H,0D7h ^ 040h     ; FLAG
        PUSH    H
        POP     PSW
        JNZ     lab6_z
        CALL    error
lab6_z:

; commands CM, CP, JM, JP, RM, RP
lab0_h:
        LXI     H,080h            ; FLAG
        PUSH    H
        POP     PSW
        CM      lab1_h
        JMP     error
lab1_h:
        POP     H
        LXI     H,0D7h ^ 080h     ; FLAG
        PUSH    H
        POP     PSW
        CP      lab2_h
        JMP     error
lab2_h:
        POP     H
        LXI     H,lab3_h
        PUSH    H
        LXI     H,080h            ; FLAG
        PUSH    H
        POP     PSW
        RM
        CALL    error
lab3_h:
        LXI     H,lab4_h
        PUSH    H
        LXI     H,0D7h ^ 080h     ; FLAG
        PUSH    H
        POP     PSW
        RP
        CALL    error
lab4_h:
        LXI     H,080h            ; FLAG
        PUSH    H
        POP     PSW
        JM      lab5_h
        CALL    error
lab5_h:
        LXI     H,0D7h ^ 080h     ; FLAG
        PUSH    H
        POP     PSW
        JP      lab6_h
        CALL    error
lab6_h:

; test indirect jumps
        LXI     H,lab7
        PCHL
        CALL    error

; djnz (and (partially) inc a, inc hl)
lab7:   MVI    A,0A5h
        MVI    B,4
lab8:   RRC
        DCR    B
        JNZ    lab8
        CPI    05Ah
        CNZ    error
        MVI    B,16
lab9:   INR    A
        DCR    B
        JNZ    lab9
        CPI    06Ah
        CNZ    error
        MVI    B,0
        LXI    H,0
lab10:  INX    H
        DCR    B
        JNZ    lab10
        MOV    A,H
        CPI    1
        CNZ    error
        MOV    A,l
        CPI    0
        CNZ    error

allok:  LXI    D,okmsg
        MVI    C,9
        CALL   5
        JMP    0

okmsg:  DB    '8080 Preliminary tests complete$'

; display address at top of stack and exit
error:  POP    B
        MVI    H,(hextab / 0FFh)
        MOV    A,B
        RRC
        RRC
        RRC
        RRC
        ANI    15
        MOV    L,A
        MOV    A,M
        CALL   conout
        MOV    A,B
        ANI    15
        MOV    L,A
        MOV    A,M
        CALL   conout
        MOV    A,C
        RRC
        RRC
        RRC
        RRC
        ANI    15
        MOV    L,A
        MOV    A,M
        CALL   conout
        MOV    A,C
        ANI    15
        MOV    L,A
        MOV    A,M
        CALL   conout
        MVI    A,13
        CALL   conout
        MVI    A,10
        CALL   conout
        JMP    0

conout: PUSH   PSW
        PUSH   B
        PUSH   D
        PUSH   H
        MVI    C,2
        MOV    E,A
        CALL   5
        POP    H
        POP    D
        POP    B
        POP    PSW
        RET

regs1:  DB     002h, 004h, 006h, 008h, 00Ah, 00Ch, 00Eh, 010h

regs2:  DS     0,8

hlval:  DB     0A5h,03Ch

        DS     0,00055h   ; next data block should be on 0x0400h
hextab: DB     '0123456789abcdef'
        DS     240

stack   EQU    $

        END