Глава IV

                Кросс-транслятор с языка ассемблер
                    микропроцессора К580ВМ80А

    В качестве  одного из элементов  данного интегрированного
комплекса предполагалось разработать кросс-транслятор с языка
ассемблер  микропроцессора К580ВМ80А  для  IBM PC-совместимых
компьютеров с целью максимально упростить разработку програм-
много обеспечения  для эмулируемой ПЭВМ - ведь не секрет, что
достаточно  скудные аппаратные ресурсы  8-битных ЭВМ  создают
немалые препятствия для программиста. С другой стороны,  сов-
ременные IBM PC-совместимые компьютеры обладают производитель-
ностью, вполне достаточной для решения подобных задач.  Этими
причинами и обусловлен тот факт, что данный подход,  а именно
создание кросс-трансляторов,  уже давно находит свое примене-
ние в мире вычислительной техники.

    Следует отметить,  что предлагаемый транслятор  может ис-
пользоваться  для  разработки   программного  обеспечения  не
только для рассматриваемой ПЭВМ "Специалист", но и вообще для
любой ЭВМ, созданной на основе микропроцессора,  совместимого
по системе команд  с процессором К580ВМ80А,  в частности  для
систем с процессором Zilog 80. Среди таких ЭВМ можно выделить
такие популярные во всем мире компьютеры, как Yamaha MSX и ZX
Spectrum, а также многочисленные восьмибитные игровые телеви-
зионные приставки. В нашей стране из машин данного типа широ-
ко известны  такие компьютеры,  как  "Микроша", "Радио-86РК",
"ЮТ-88"  и  многие другие.  Таким образом,  системы на основе
данного микропроцессора  остаются  популярными и по сей день,
и число их  довольно  велико.  Следовательно,  можно уверенно
рассчитывать на то, что предлагаемый транслятор будет пользо-
ваться немалым спросом среди широкого круга любителей.

    Предлагаемая  программа  реализована  в  виде автономного
исполнимого модуля на языке C++. Модуль рассчитан на исполне-
ние в операционной системе MS-DOS,  но,  поскольку программы,
написанные  на  языке  C++  и  использующие  его  стандартные
системные  вызовы,  как  правило,  обладают  высокой степенью
переносимости,  он может быть оттранслирован  и будет успешно
работать на любой платформе, имеющей транслятор с языка C++.

    Для  запуска  транслятора из командной строки  необходимо
ввести следующее:

         C> kasm <имя-файла>

    Транслятор   выполнит   ассемблирование  файла  с  именем
<имя-файла> и запишет полученный двоичный код в файл с именем
IMAGE.BIN. Если транслятор обнаружит ошибки,  их список будет
выведен на экран  с указанием строки,  в которой была найдена
ошибка. При этом файл IMAGE.BIN создан не будет.

    При  запуске  транслятора  без  параметров  будет  выдано
сообщение, описывающее способ использования программы.

    Структура программы

    Данная программа реализована  в виде  следующих файлов на
языке C++:

 Файл ASM.CPP    Главный файл программы.  Содержит подпро-
                 граммы, необходимые  для  синтаксического
                 анализа  текста   ассемблерной  программы
                 и генерации двоичного кода,  средства ди-
                 агностики ошибок, а также средства файло-
                 вого ввода/вывода.

 Файл ASM.H      Заголовочный файл для файла ASM.CPP.

 Файл HTABLE.CPP Содержит реализацию класса "хэш-таблица".
		 Хзш-таблица используется  в качестве хра-
                 нилища меток и EQU-определений ассемблер-
                 ной программы.

 Файл HTABLE.H	 Заголовочный файл для файла HTABLE.CPP.
		 Содержит описание класса "хэш-таблица".

 Файл ERRORS.CPP Содержит  подпрограммы  вывода  на  экран
		 сообщений об ошибках,  фатальных  ошибках
		 и  предупредительных сообщений,  а  также
		 сами сообщения.

 Файл ERRORS.H	Заголовочный файл для файла ERRORS.CPP.
		Содержит константы, используемые для ссыл-
                ки на конкретное сообщение об ошибке.


    Требования к ассемблерному тексту

    Ассемблерный текст,  поступающий на вход программе, трак-
туется ею как последовательность строк следующего формата:

[ws][<label>[ws]:[ws]][<opcode>ws[<operands>]][ws][;<comment>]

где:

    ws (white space) - разделитель, в данном случае табуляция
                       или пробел

    <label>          - имя метки  (в имени  допустимы  буквы,
                       цифры и некоторые специальные символы,
                       при этом цифры в начале имени недопус-
                       тимы)

    <opcode>         - ассемблерная мнемоника  кода операции.
                       Список мнемоник см. в Приложении 2. В
                       этом поле также могут  находиться  так
                       называемые псевдооперации (см. ниже)

    <operands>	     - операнды для команды, указанной в пре-
                       дыдущем поле

    <comment>	     - комментарий до конца строки

    (Квадратные скобки означают необязательность параметра.)

    Как следует из вышеприведенного шаблона строки,  в тексте
    допустимы:

	    - пустые строки;
	    - строки, состоящие из одного комментария;
	    - строки, состояшие из одной метки;
	    - строки, состоящие из одной команды со своими
              операндами;
	    - все комбинации вышеперечисленных строк.

    При этом считаются недопустимыми  строки,  в которых при-
сутствуют две или более меток или же две или более команд.

    Транслятор  обрабатывает строки  не длиннее  127 символов
(считая разделители и комментарии).  Как правило, для ассемб-
лерных программ  этого достаточно  вследствие  ограниченности
длины команд. Если транслятор обнаруживает строку длиннее 127
символов, строка усекается  и на экран выдается соответствую-
щее предупредительное сообщение.

    Признаком конца ассемблерного текста  может являться клю-
чевое слово END. При этом оно не обязательно должно находить-
ся в конце файла - в этом случае весь текст после этого слова
будет проигнорирован. В случае отсутствия слова END весь файл
просматривается до конца.

    Помимо  ассемблерных  мнемоник,  программа распознает ряд
так называемых псевдоопераций, а именно DB, DW, DS, ORG и EQU.
Их синтаксис приводится ниже.

		DB	<list_of_bytes>
		DW	<list_of_words>

    Эти две операции используются для записи в память восьми-
и шестнадцатибитных констант соответственно. Список этих кон-
стант задается в виде чисел, символьных констант или символи-
ческих имен, разделенных запятыми. Для записи в память строки
символов можно также записать ее в качестве одной из констант,
заключив ее  в двойные кавычки  (такие строки  обе эти псевдо-
операции трактуют одинаково).

		DS	<integer>

    Эта псевдооперация резервирует в памяти число байт,  ука-
занное в поле операнда.  Содержимое этих ячеек  перед началом
работы оттранслированной программы не определено.

		ORG	<integer>

    Псевдооперация ORG указывает транслятору, с какого адреса
предполагается размещение в памяти оттранслированной програм-
мы при запуске ее на целевой ЭВМ. Она необходима для коррект-
ного перевода  символических  имен  меток  в адреса  и должна
встречаться в тексте программы до первой команды и до первого
объявления метки. Отсутствие псевдооперации ORG в тексте про-
граммы  эквивалентно  команде  ORG  0.  Псевдооперация ORG не
записывает никакого кода в выходной файл.

<label> :	EQU	<integer>

    Псевдооперация EQU присваивает имени метки,  предшествую-
щей ей,  значение,  указанное в поле <integer>.  Впоследствии
эту метку можно будет использовать  в качестве целочисленного
операнда.  (В принципе,  в качестве  целочисленного  операнда
можно использовать любую метку,  так  как  значение метки, не
связанной с псевдооперацией EQU, считается равным адресу,  по
которому эта метка была определена.) Эта псевдооперация также
не записывает никакого кода в выходной файл.


    Принцип работы программы

    В ходе трансляции входного текста транслятор последовате-
льно просматривает его строки,  анализирует  их  и генерирует
соответствующий двоичный код, записывая его в выходной файл.

    В предлагаемом трансляторе реализован синтаксический ана-
лизатор,  принимающий на вход текстовую строку формата,  опи-
санного в предыдущем подразделе.  Выделение отдельных элемен-
тов строки производится  путем поиска  в ней  соответствующих
разделительных символов (для выделения метки - ':', для отде-
ления мнемоники от операндов - пробела или табуляции).  Обра-
ботка соответствующих элементов производится последовательно,
по мере их выделения.

    В данной реализации трансляция происходит в два прохода:

 На первом проходе  транслятор распознает метки  и записывает
 соответствующие  им  адреса  в хэш-таблицу.  Для корректного
 вычисления  адресов  меток  транслятор распознает  мнемоники
 ассемблерных  команд  и вычисляет длину  соответствуюшего им
 двоичного кода.  При этом  распознавание операндов команд не
 требуется, так как  в системе команд данного микропроцессора
 длина команды в машинном коде не зависит от ее операндов. На
 этом этапе в выходной файл ничего не записывается  и сообще-
 ния об ошибках не генерируются (кроме фатальных ошибок).

 На втором проходе  транслятор  игнорирует метки,  распознает
 ассемблерные мнемоники и операнды, генерируя соответствующий
 им двоичный код и  записывая его в выходной файл.  При этом,
 если   в качестве операнда команды указывается символическое
 имя, транслятор производит его поиск в хэш-таблице и подста-
 вляет  в команду значение этого имени.  На этом этапе  могут
 возникать  сообщения об ошибках  и предупредительные сообще-
 ния.

    Обработка  мнемоник  ассемблерных  команд  осуществляется
следующим образом:

 Производится  поиск  по имени команды в таблице команд.  Для
 ускорения поиска  таблица проиндексирована  по первой букве.
 Затем управление  передается  на один из двенадцати обработ-
 чиков операндов  в зависимости от типа команды.  Нужно отме-
 тить,  что по типу и способу кодировки операндов все команды
 данного микропроцессора  можно условно разделить на 12 групп
 - например, команды, не требующие операндов,  команды,  тре-
 бующие 8-битовую константу и т.п. В данной реализации каждой
 такой группе соответствует свой обработчик, которому переда-
 ется часть входной строки,  оставшаяся после обработки имени
 команды.  Каждый такой обработчик  пытается выделить из этой
 строки операнды команды  и возвращает  в вызывающую подпрог-
 рамму от 1 до 3 байт двоичного кода,  соответствующего коди-
 ровке  прочитанных им  операндов  для данной группы  команд.
 Вызывающая  подпрограмма  корректирует  этот код  (а именно,
 добавляет  к первому байту кода  так называемый  базовый код
 уже  конкретной  команды)  и записывает его  в выходной файл
 (вызывающей подпрограмме известна  длина машинного кода  для
 каждой группы команд).


    Виды поддерживаемых констант

    Для команд и псевдоопераций,  требующих в качестве одного
из аргументов восьми- или шестнадцатибитную константу, допус-
тимы следующие виды констант:

    - Знаковое целое, записанное в десятичной системе.

    - Знаковое целое, записанное в двоичной системе
      (признак - буква b, непосредственно следующая за после-
      дней цифрой).

    - Знаковое целое,  записанное в шестнадцатиричной системе
      (признак - буква h, непосредственно следующая за после-
      дней цифрой). Если число начинается с шестнадцатиричной
      цифры A..F, то перед ней необходимо поставить цифру 0.

    - Символьная константа, состоящая из одного или двух сим-
      волов, заключенных в апострофы.

    - Символ $, равный адресу строки, в которой он расположен.

    - Имя метки. Его значением является адрес строки, в кото-
      рой метка была определена.

    - Имя EQU-определения.  Его значением является константа,
      записанная в соответствующем EQU-определении.

    Если команде,  требующей восьмибитную константу,  указать
операнд,  не помещающийся в один байт,  будет выдано соответ-
ствующее предупредительное сообщение.


	Как проводилось тестирование

    После длительного обдумывания  были установлены следующие
основные требования, предъявляемые к этапу тестирования:

    - Тесты должны проверять корректность  работы транслятора
      со всеми строками, соответствующими указанному в специ-
      фикации формату.

    - Тесты должны проверять правильность  работы  всех обра-
      ботчиков операндов (в частности, корректность генериру-
      емых ими адресов).

    - Тесты должны проверять корректность работы системы диа-
      гностики ошибок.

    - Тесты должны позволять исследовать  поведение системы в
      экстремальных ситуациях (тест на фатальные ошибки).

    Для  реализации  всех перечисленных этапов  были написаны
три тестовых файла TEST1.ASM, TEST2.ASM и SNAKE.ASM.  Все эти
файлы,  а также распечатки состояния экрана  после трансляции
этих файлов приводятся в приложении 6.
