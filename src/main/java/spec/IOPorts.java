package spec;

import java.util.Arrays;

import static spec.Constants.ROM;

public class IOPorts {

    private boolean Ain = true;  // порт A на ввод
    private boolean Bin = true;  // порт B на ввод
    private boolean C0in = true;  // порт C0 на ввод
    private boolean C1in = true;  // порт C1 на ввод
    private boolean shift = false; // Shift не нажат

    private static final int PortA = 0xFFE0; // Порт А ППА
    private static final int PortB = 0xFFE1; // Порт В ППА
    private static final int PortC = 0xFFE2; // Порт С ППА
    private static final int RgRYS = 0xFFE3; // рег. Упр.Слова ППА
    public static final int RgRGB = 0xFFF8; // порт контроллера цвета

    // маски битов
    private final int[] bit = {0x00FE, 0x00FD, 0x00FB, 0x00F7, 0x00EF, 0x00DF, 0x00BF, 0x007F};

    // биты установки
    private final int[] msk = {0x0001, 0x0002, 0x0004, 0x0008, 0x0010, 0x0020, 0x0040, 0x0080};

    //  массив возможных ascii-кодов нажатых клавиш...
//  23 строки по 8 = 184 + 4 + 2 + 2 = 192 клавиши.
//                                   <BckSpc> <Tab>   <Enter> <Esc>
    private final int[] ascii_keys = {0x0008, 0x0009, 0x000A, 0x001B,
//          <Space>  | ! |   | " |   | # |   | $ |   | % |   | & |   | ' |
            0x0020, 0x0021, 0x0022, 0x0023, 0x0024, 0x0025, 0x0026, 0x0027,
//           | ( |   | ) |   | * |   | + |   | , |   | - |   | . |   | / |
            0x0028, 0x0029, 0x002A, 0x002B, 0x002C, 0x002D, 0x002E, 0x002F,
//           | 0 |   | 1 |   | 2 |   | 3 |   | 4 |   | 5 |   | 6 |   | 7 |
            0x0030, 0x0031, 0x0032, 0x0033, 0x0034, 0x0035, 0x0036, 0x0037,
//           | 8 |   | 9 |   | : |   | ; |   | < |   | = |   | > |   | ? |
            0x0038, 0x0039, 0x003A, 0x003B, 0x003C, 0x003D, 0x003E, 0x003F,
//           | @ |   | A |   | B |   | C |   | D |   | E |   | F |   | G |
            0x0040, 0x0041, 0x0042, 0x0043, 0x0044, 0x0045, 0x0046, 0x0047,
//           | H |   | I |   | J |   | K |   | L |   | M |   | N |   | O |
            0x0048, 0x0049, 0x004A, 0x004B, 0x004C, 0x004D, 0x004E, 0x004F,
//           | P |   | Q |   | R |   | S |   | T |   | U |   | V |   | W |
            0x0050, 0x0051, 0x0052, 0x0053, 0x0054, 0x0055, 0x0056, 0x0057,
//           | X |   | Y |   | Z |   | [ |   | \ |   | ] |   | ^ |   | _ |
            0x0058, 0x0059, 0x005A, 0x005B, 0x005C, 0x005D, 0x005E, 0x005F,
//           | ` |   | a |   | b |   | c |   | d |   | e |   | f |   | g |
            0x0060, 0x0061, 0x0062, 0x0063, 0x0064, 0x0065, 0x0066, 0x0067,
//           | h |   | i |   | j |   | k |   | l |   | m |   | n |   | o |
            0x0068, 0x0069, 0x006A, 0x006B, 0x006C, 0x006D, 0x006E, 0x006F,
//           | p |   | q |   | r |   | s |   | t |   | u |   | v |   | w |
            0x0070, 0x0071, 0x0072, 0x0073, 0x0074, 0x0075, 0x0076, 0x0077,
//           | x |   | y |   | z |   | { |   | | |   | } |   | ~ |   <Del>
            0x0078, 0x0079, 0x007A, 0x007B, 0x007C, 0x007D, 0x007E, 0x007F,
//           <Home>  <End>   <PgUp>  <PgDn>  < Up >  <Down>  <Left> <Right>
            0x03E8, 0x03E9, 0x03EA, 0x03EB, 0x03EC, 0x03ED, 0x03EE, 0x03EF,
//           <F1>    <F2>    <F3>    <F4>    <F5>    <F6>    <F7>    <F8>
            0x03F0, 0x03F1, 0x03F2, 0x03F3, 0x03F4, 0x03F5, 0x03F6, 0x03F7,
//           <F9>    <F10>   <F11>   <F12>  <CpsLk>
            0x03F8, 0x03F9, 0x03FA, 0x03FB, 0x03FE,
//         <Insert> = ПВ [ Ё ]!;
            0x0401,
//           | А |   | Б |   | В |   | Г |   | Д |   | Е |   | Ж |   | З |
            0x0410, 0x0411, 0x0412, 0x0413, 0x0414, 0x0415, 0x0416, 0x0417,
//           | И |   | Й |   | К |   | Л |   | М |   | Н |   | О |   | П |
            0x0418, 0x0419, 0x041A, 0x041B, 0x041C, 0x041D, 0x041E, 0x041F,
//           | Р |   | С |   | Т |   | У |   | Ф |   | Х |   | Ц |   | Ч |
            0x0420, 0x0421, 0x0422, 0x0423, 0x0424, 0x0425, 0x0426, 0x0427,
//           | Ш |   | Щ |   | Ъ |   | Ы |   | Ь |   | Э |   | Ю |   | Я |
            0x0428, 0x0429, 0x042A, 0x042B, 0x042C, 0x042D, 0x042E, 0x042F,
//           | а |   | б |   | в |   | г |   | д |   | е |   | ж |   | з |
            0x0430, 0x0431, 0x0432, 0x0433, 0x0434, 0x0435, 0x0436, 0x0437,
//           | и |   | й |   | к |   | л |   | м |   | н |   | о |   | п |
            0x0438, 0x0439, 0x043A, 0x043B, 0x043C, 0x043D, 0x043E, 0x043F,
//           | р |   | с |   | т |   | у |   | ф |   | х |   | ц |   | ч |
            0x0440, 0x0441, 0x0442, 0x0443, 0x0444, 0x0445, 0x0446, 0x0447,
//           | ш |   | щ |   | ъ |   | ы |   | ь |   | э |   | ю |   | я |
            0x0448, 0x0449, 0x044A, 0x044B, 0x044C, 0x044D, 0x044E, 0x044F,
//           | ё |   | № |
            0x0451, 0x2116
    };

//  массив позиций матрицы "Специалиста" для возможных ascii-кодов нажатых клавиш...
//  двухбайтное значение:0xXXYY, установка старшего бита = нажатию Shift(HP)
//  уточнить значения клавиш: <CapsLock> и Р/Л действуют в противофазе!
//  23 строки по 8 = 184 + 4 + 2 + 2 = 192 клавиши.

    //                                     <BckSpc>  <Tab>  <Enter> <Esc>
    private final short[] keyboard = {0x0001, 0x0600, 0x0000, 0x0700,
//          <Space>  | ! |   | " |   | # |   | $ |   | % |   | & |   | ' |
            0x0500, 0x7a04, 0x7904, 0x7804, 0x7704, 0x7604, 0x7504, 0x7404,
//           | ( |   | ) |   | * |   | + |   | , |   | - |   | . |   | / |
            0x7304, 0x7204, 0x0003, 0x7b04, 0x0201, 0x0004, 0x0002, 0x0101,
//           | 0 |   | 1 |   | 2 |   | 3 |   | 4 |   | 5 |   | 6 |   | 7 |
            0x0104, 0x0a04, 0x0904, 0x0804, 0x0704, 0x0604, 0x0504, 0x0404,
//           | 8 |   | 9 |   | : |   | ; |   | < |   | = |   | > |   | ? |
            0x0304, 0x0204, 0x7003, 0x0b03, 0x7201, 0x7004, 0x0002, 0x0101,
//           | @ |   | A |   | B |   | C |   | D |   | E |   | F |   | G |
            0x0301, 0x0802, 0x0401, 0x0a03, 0x0302, 0x0703, 0x0b02, 0x0503,
//           | H |   | I |   | J |   | K |   | L |   | M |   | N |   | O |
            0x0103, 0x0701, 0x0b03, 0x0803, 0x0402, 0x0801, 0x0603, 0x0502,
//           | P |   | Q |   | R |   | S |   | T |   | U |   | V |   | W |
            0x0702, 0x0b01, 0x0602, 0x0901, 0x0601, 0x0903, 0x0202, 0x0902,
//           | X |   | Y |   | Z |   | [ |   | \ |   | ] |   | ^ |   | _ |
            0x0501, 0x0a02, 0x0203, 0x0403, 0x0102, 0x0303, 0x0A01, 0x0001,
//           | ` |   | a |   | b |   | c |   | d |   | e |   | f |   | g |
            0x0b04, 0x7802, 0x7401, 0x7a03, 0x7302, 0x7703, 0x7B02, 0x7503,
//           | h |   | i |   | j |   | k |   | l |   | m |   | n |   | o |
            0x7103, 0x7701, 0x7B03, 0x7803, 0x7402, 0x7801, 0x7603, 0x7502,
//           | p |   | q |   | r |   | s |   | t |   | u |   | v |   | w |
            0x7702, 0x7B01, 0x7602, 0x7901, 0x7601, 0x7903, 0x7202, 0x7902,
//           | x |   | y |   | z |   | { |   | | |   | } |   | ~ | <Del>
            0x7501, 0x7A02, 0x7203, 0x7403, 0x7102, 0x7303, 0x7B04, 0x0005,
//          <Home>  <End>   <PgUp>  <PgDn>  < Up >  <Down> <Left> <Right>*/
            0x0B05, 0x0A05, 0x0A00, 0x0100, 0x0900, 0x0800, 0x0400, 0x0200,
//           <F1>    <F2>    <F3>    <F4>    <F5>    <F6>   <F7>   <F8>
            0x0B05, 0x0A05, 0x0905, 0x0805, 0x0705, 0x0605, 0x0505, 0x0405,
//           <F9>    <F10>   <F11>   <F12>  <CpsLk> = Р/Л
            0x0305, 0x0205, 0x0105, 0x0005, 0x0700,
//          <Insert> = ПВ [ Ё ]!;
            0x0300,
//           | А |   | Б |   | В |   | Г |   | Д |   | Е |   | Ж |   | З |
            0x0802, 0x0401, 0x0902, 0x0503, 0x0302, 0x0703, 0x0202, 0x0203,
//           | И |   | Й |   | К |   | Л |   | М |   | Н |   | О |   | П |
            0x0701, 0x0B03, 0x0803, 0x0402, 0x0801, 0x0603, 0x0502, 0x0702,
//           | Р |   | С |   | Т |   | У |   | Ф |   | Х |   | Ц |   | Ч |
            0x0602, 0x0901, 0x0601, 0x0903, 0x0B02, 0x0103, 0x0A03, 0x0A01,
//           | Ш |   | Щ |   | Ъ |   | Ы |   | Ь |   | Э |   | Ю |   | Я |
            0x0403, 0x0303, 0x0001, 0x0A02, 0x0501, 0x0102, 0x0301, 0x0B01,
//           | а |   | б |   | в |   | г |   | д |   | е |   | ж |   | з |
            0x7802, 0x7401, 0x7902, 0x7503, 0x7302, 0x7703, 0x7202, 0x7203,
//           | и |   | й |   | к |   | л |   | м |   | н |   | о |   | п |
            0x7701, 0x7B03, 0x7803, 0x7402, 0x7801, 0x7603, 0x7502, 0x7702,
//           | р |   | с |   | т |   | у |   | ф |   | х |   | ц |   | ч |
            0x7602, 0x7901, 0x7601, 0x7903, 0x7B02, 0x7103, 0x7A03, 0x7A01,
//           | ш |   | щ |   | ъ |   | ы |   | ь |   | э |   | ю |   | я |
            0x7403, 0x7303, 0x7001, 0x7A02, 0x7501, 0x7102, 0x7301, 0x7B01,
//           | ё |   | № |
            0x7b04, 0x7804
    };

    // массив матрицы клавш "Специалиста" ( true - нажата, false - отпущена)
    // 12 x 6 + Shift + Reset
    private boolean[][] keyStatus = new boolean[12][6];

    private Memory memory;

    public IOPorts(Memory memory) {
        this.memory = memory;
    }

    /**
     * Матрица клавиш 12х6. True = замкнуто, False = разомкнуто
     * ======================================================================================
     *       C3    C2    C1    C0    A7    A6    A5    A4    A3    A2    A1    A0  <==:ПОРТ:|
     * ============================================================================      |  |
     *    | X_B | X_A | X_9 | X_8 | X_7 | X_6 | X_5 | X_4 | X_3 | X_2 | X_1 | X_0 |      |  |
     * ==================================================================================^==|
     * Y5 |  F  |  F1 |  F2 |  F3 |  F4 |  F5 |  F6 |  F7 |  F8 | [X] | [ ] | [/] | 05 | B5 |
     * Y4 | + ; | ! 1 | " 2 | # 3 | $ 4 | % 5 | & 6 | ' 7 | ( 8 | ) 9 |   0 | = = | 04 | B4 |
     * Y3 | J Й | C Ц | U У | K K | E E | N Н | G Г | [ Ш | ] Щ | Z З | H Х | : * | 03 | B3 |
     * Y2 | F Ф | Y Ы | W В | A A | P П | R Р | O O | L Л | D Д | V Ж | \ Э | . > | 02 | B2 |
     * Y1 | Q Я | ^ Ч | S С | M M | I И | T T | X Ь | B Б | @ Ю | < , | ? / |  ЗБ | 01 | B1 |
     * Y0 | Р/Л |HOME |  Up |Down | ESC | TAB | SPС |  <= |  ПВ |  => |  ПС |  ВК | 00 | B0 |
     * ==============================================================================^======|
     *      0b    0a    09    08    07    06    05    04    03    02    01    00 <=X/Y      |
     **/

    // ввод из порта памяти 580ВВ55
    public int inPort(int addr) {
        // все порты ППА перенесём в область 0xFFE0 - 0xFFE3
        if (addr <= RgRYS) {
            addr = shiftPortAddress(addr);
        }

        int result = 0b1111_1111; // предварительно ни одна кнопка не нажата
        // port 580BB55
        if (addr > ROM.end() && addr < RgRYS) {
            // разбираем по каналам...
            switch (addr) {
                case PortA: {
                    // если порт A - на ввод
                    if (Ain) {
                        // если порт B - на вывод
                        if (!Bin) {
                            // по битам порта B от 2 до 7
                            for (int i = 0; i < 6; i++) {
                                // по битам порта A от 0 до 7
                                for (int j = 0; j < 8; j++)  {
                                    // если такая нажата  и  такой бит порта B = 0, ставим бит A = 0
                                    if (keyStatus[j][i] && (B() & msk[i + 2]) == 0) {
                                        result &= bit[j];
                                    }
                                }
                            }
                            //  возвращаем состояние порта A
                            return result;
                        }
                        // если порт B - на ввод то и делать нечего
                    }
                    //  порта A - на вывод < последнее записанное
                    return A();
                }

                // Порт В
                case PortB: {
                    // если порта В - на ввод
                    if (Bin) {
                        // если порт A - на вывод
                        if (!Ain) {
                            // по битам порта A от 0 до 7
                            for (int i = 0; i < 8; i++) {
                                // по битам порта В от 2 до 7
                                for (int j = 0; j < 6; j++)  {
                                    // если такая нажата  и  такой бит порта A = 0, ставим бит В = 0
                                    if (keyStatus[i][j] && (A() & msk[i]) == 0) {
                                        result &= bit[j + 2];
                                    }
                                }
                            }
                        }

                        // если порт CLow - на вывод
                        if (!C0in) {
                            // по битам порта CLow от 0 до 3
                            for (int i = 0; i < 4; i++) {
                                // по битам порта В от 2 до 7
                                for (int j = 0; j < 6; j++) {
                                    // если такая нажата  и  такой бит порта C = 0, ставим бит В = 0
                                    if (keyStatus[i + 8][j] && (C() & msk[i]) == 0) {
                                        result &= bit[j + 2];
                                    }
                                }
                            }
                        }

                        // если порт C - на ввод то и делать нечего
                        // если порт A - на ввод то и делать нечего

                        // КАКОЙ_ТО КОНФЛИКТ СО <CapsLock> - он работает наоборот
                        // <CpsLk> = Р/Л ЭТО ДАЁТ СБОЙ ЗДЕСЬ Т.К. ВЛИЯЕТ НА КОД КЛАВИШИ!!!
                        // в Мониторе "Shift" не влияет на клавишу. Влияет РУС/ЛАТ (НР.ФИКС) !!!
                        if (!shift) {
                            result |= 0b0000_0010; // выставим состояние Shift: B1 = 1
                        }

                        //  возвращаем состояние порта В
                        return result;
                    }
                    //  порта В - на вывод < последнее записанное
                    return B();
                }

                // Порт С orphaned default
                default: {
                    // если порта CLow - на ввод
                    if (C0in) {
                        // если порт B - на вывод
                        if (!Bin) {
                            // по битам порта B от 2 до 7
                            for (int i = 0; i < 6; i++) {
                                // по битам порта CLow от 0 до 3
                                for (int j = 0; j < 4; j++) {
                                    // если такая нажата  и  такой бит порта В = 0, ставим бит C = 0
                                    if (keyStatus[j + 8][i] && (B() & msk[i + 2]) == 0) {
                                        result = result & bit[j];
                                    }
                                }
                            }
                            //  возвращаем состояние порта C
                            return result;
                        }
                    } else {
                        // если порта CLow - на вывод
                        return C() & 0b0000_1111 | 0b1111_0000;
                    }
                }
                //ЗДЕСЬ - ПОДУМАТЬ И ПРОВЕРИТЬ!!!
            }
        } else {
            // остальные порты и РУС ВРЕМЕННО считаем ячейками памяти!
            result = memory.read8(addr);
        }
        return result;
    }

    public void outPort(int addr, int bite) {
        // все порты ППА перенесём в область 0xFFE0 - 0xFFE3
        if (addr <= RgRYS) {
            addr = shiftPortAddress(addr);
        }

        // Разбор управляющего слова ППА 580ВВ55
        // РУС
        if (addr == RgRYS) {
            // управляющие слова 1-старший бит
            if ((bite & 0b1000_0000) != 0) {
                // КАНАЛ_С(МЛ.)(РС0-РС3)
                C0in = (bite & 0b0000_0001) != 0;
                if (!C0in) {
                    C(C() & 0b1111_0000);
                }
                // КАНАЛ_В(РВ0-РВ7)
                Bin = (bite & 0b0000_0010) != 0;
                if (!Bin) {
                    B(0);
                }
                // КАНАЛ_С(СТ.)(РС4-РС7)
                C1in = (bite & 0b0000_1000) != 0;
                if (!C1in) {
                    C(C() & 0b0000_1111);
                }
                // КАНАЛ_A(РА0-РА7)
                Ain = (bite & 0b0001_0000) != 0;
                if (!Ain) {
                    A(0);
                }
                // в ПОРТ RYC запишем YC ПОРТЫ 0xFFE3
                memory.write8(addr, bite);
                return;
            } else {
                // побитное управление портом 0xFFE3
                // если порт C0- на вывод
                if (!C0in) {
                    if ((bite & 0b0000_0001) == 1) {
                        // биты 0-3
                        // уст. в 1
                        if (((bite & 0b0000_1110) >> 1) < 4) {
                            C(C() | msk[((bite & 0b0000_1110) >> 1)]);
                        }
                    } else {
                        // биты 0-3
                        // уст. в 0
                        if (((bite & 0b0000_1110) >> 1) < 4) {
                            C(C() & bit[((bite & 0b0000_1110) >> 1)]);
                        }
                    }
                }
                // если порт C1- на вывод
                if (!C1in) {
                    if ((bite & 0b0000_0001) == 1) {
                        // биты 4-7
                        // уст. в 1
                        if (((bite & 0b0000_1110) >> 1) > 3) {
                            int b = C();
                            C(b | msk[((b & 0b0000_1110) >> 1)]);
                        }
                    } else {
                        // биты 4-7
                        // уст. в 0
                        if (((bite & 0b0000_1110) >> 1) > 3) {
                            int b = C();
                            C(b & bit[((b & 0b0000_1110) >> 1)]);
                        }
                    }
                }
            }
        }
        // в остальные ПОРТЫ : в том числе и 0xFFF8 - цвет
        // пишем в память: 0xC000 < ПОРТЫ < 0xFFFF
        memory.write8(addr, bite);
    }

    private int A() {
        return memory.read8(PortA);
    }

    private void A(int bite) {
        memory.write8(PortA, bite);
    }

    private int B() {
        return memory.read8(PortB);
    }

    private void B(int bite) {
        memory.write8(PortB, bite);
    }

    private int C() {
        return memory.read8(PortC);
    }

    private void C(int bite) {
        memory.write8(PortC, bite);
    }

    private int shiftPortAddress(int addr) {
        return (addr & 0x0003) | 0xFFE0;
    }

    // переменные-заготовки для полу-рядов матрицы клавиатуры .
    // значение в них устанавливается при нажатии-отпускании клавиши.
    // в порт клавиатуры - xxfeh они записываются во время его опроса
    // согласно "0", выбирающему конкретный полуряд: public int inb( int port )

    public void resetKeyboard() {
        for (int i = 0; i < 12; i++) {  // все кнопки ненажаты
            for (int j = 0; j < 6; j++) {
                keyStatus[i][j] = false;
            }
        }
    }

    public void processKey(boolean down, int ascii) {
        // находим индекс Ascii-кода нажатой или отпущенной клавиши.
        int index = Arrays.binarySearch(ascii_keys, ascii);
        // если она есть в таблице:
        if (index >= 0) {
            // по индексу находим "координату" в матрице X_Y
            short point = keyboard[index];
            int x = (point & 0x0F00) >> 8;
            int y = point & 0x00FF;

            // по координате установим "нажатие" В таблице матрицы Специалиста.
            // нажата(отпущена)
            keyStatus[x][y] = down;
            // какой_то конфликт СО <CapsLock> - он работает наоборот
            // в МОНИТОРЕ Shift не влияет. Влияет РУС/ЛАТ = НР_ФИКС.
            if ((point & 0x7000) == 0) {
                // если старший ниббл - заглавные символы
                //  Shift не нажат
                shift = false;
            } else {
                // если нет старшего ниббла - строчные: старший бит = 1
                // Shift нажат (отпущен)
                shift = down;
            }
        }
    }

    public void reset() {
        shift = false; // Shift не нажат
        Ain = true;    // порт A на ввод
        Bin = true;    // порт B на ввод
        C0in = true;   // порт C0 на ввод
        C1in = true;   // порт C1 на ввод

        // сортируем массив ascii-массив кодов клавиш для поиска
        Arrays.sort(ascii_keys);

        // все кнопки не нажаты
        resetKeyboard();

        // порт RYC[0xFFE3] = 9Bh (все на ввод)
        memory.write16(RgRYS, 0x009B);

        // порт цвета - зелёный на черном.
        memory.write16(RgRGB, 0x0020);
    }
}